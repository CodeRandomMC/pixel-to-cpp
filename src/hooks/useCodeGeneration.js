/*
 * Pixel2CPP - Code Generation Hook
 * 
 * MIT License
 * Copyright (c) 2025 CodeRandom
 * 
 * This software is provided free of charge for educational and personal use.
 * Commercial use and redistribution must comply with the MIT License terms.
 */

import { useState } from "react";
import { pack1bit, pack1bitAlpha, packRGB565, packRGB24, packRGB332, packGray4 } from "../lib/packers.js";
import { download, copyToClipboard } from "../lib/io.js";

/**
 * Custom hook to manage code generation and export functionality
 * 
 * @returns {Object} Code generation state and methods
 */
export function useCodeGeneration() {
  const [showCodeModal, setShowCodeModal] = useState(false);
  const [copyStatus, setCopyStatus] = useState("");
  const [isGenerating, setIsGenerating] = useState(false);

  const generateCppCode = (drawMode, outputFormat, w, h, data, name) => {
    const safeName = name.replace(/[^a-zA-Z0-9_]/g, "_");
    
    console.log('generateCppCode called with:', { drawMode, outputFormat, w, h, dataLength: data.length });
    
    // Validate data
    if (!data || data.length !== w * h) {
      console.error('Invalid data:', { dataLength: data?.length, expectedLength: w * h, w, h });
      return `// Error: Invalid data array (length: ${data?.length}, expected: ${w * h})`;
    }
    
    // Helper function to safely call packer functions
    const safePack = (packerFunc, ...args) => {
      try {
        const result = packerFunc(...args);
        console.log(`${packerFunc.name} result:`, result.length, 'bytes');
        return result;
      } catch (error) {
        console.error(`Error in ${packerFunc.name}:`, error);
        return [];
      }
    };
    
    // Determine data and format based on draw mode
    let bytes = [], dataType = "uint8_t", dataFormat = "pixels";
    
    if (drawMode === "HORIZONTAL_1BIT") {
      bytes = safePack(pack1bit, data, w, h, 'horizontal');
      dataType = "uint8_t";
      dataFormat = "bits";
    } else if (drawMode === "VERTICAL_1BIT") {
      bytes = safePack(pack1bit, data, w, h, 'vertical');
      dataType = "uint8_t";
      dataFormat = "bits";
    } else if (drawMode === "HORIZONTAL_ALPHA") {
      bytes = safePack(pack1bitAlpha, data, w, h, 'horizontal');
      dataType = "uint8_t";
      dataFormat = "alpha";
    } else if (drawMode === "HORIZONTAL_RGB565") {
      bytes = safePack(packRGB565, data, w, h);
      dataType = "uint16_t";
      dataFormat = "pixels";
    } else if (drawMode === "HORIZONTAL_RGB888_24") {
      bytes = safePack(packRGB24, data, w, h);
      dataType = "uint8_t";
      dataFormat = "pixels";
    } else if (drawMode === "HORIZONTAL_RGB888_32") {
      // 32-bit RGBA format
      bytes = [];
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const p = data[y * w + x];
          bytes.push(p.r, p.g, p.b, p.a);
        }
      }
      dataType = "uint8_t";
      dataFormat = "pixels";
    } else if (drawMode === "HORIZONTAL_RGB332") {
      bytes = safePack(packRGB332, data, w, h);
      dataType = "uint8_t";
      dataFormat = "pixels";
    } else if (drawMode === "HORIZONTAL_GRAY4") {
      bytes = safePack(packGray4, data, w, h);
      dataType = "uint8_t";
      dataFormat = "pixels";
    } else {
      // Fallback for unknown draw modes - use 1-bit horizontal
      console.warn(`Unknown draw mode: ${drawMode}, falling back to HORIZONTAL_1BIT`);
      bytes = safePack(pack1bit, data, w, h, 'horizontal');
      dataType = "uint8_t";
      dataFormat = "bits";
    }
    
    console.log('Generated bytes:', { bytesLength: bytes.length, dataType, dataFormat });
    
    // Validate bytes were generated
    if (!bytes || bytes.length === 0) {
      console.error('No bytes generated');
      return `// Error: No bytes generated for ${drawMode} format`;
    }
    
    // Generate byte string based on output format
    try {
      if (outputFormat === "PLAIN_BYTES") {
        return generatePlainBytes(bytes, safeName, w, h, dataType, dataFormat, drawMode);
      } else if (outputFormat === "ARDUINO_CODE") {
        return generateArduinoCode(bytes, safeName, w, h, dataType, dataFormat, drawMode);
      } else if (outputFormat === "ARDUINO_SINGLE_BITMAP") {
        return generateArduinoSingleBitmap(bytes, safeName, w, h, dataType, dataFormat);
      } else if (outputFormat === "GFX_BITMAP_FONT") {
        return generateGFXBitmapFont(bytes, safeName, w, h);
      } else {
        console.warn(`Unknown output format: ${outputFormat}, falling back to ARDUINO_CODE`);
        return generateArduinoCode(bytes, safeName, w, h, dataType, dataFormat, drawMode);
      }
    } catch (error) {
      console.error('Error generating output format:', error);
      return `// Error generating ${outputFormat} format: ${error.message}`;
    }
  };

  // Output format generators
  const generatePlainBytes = (bytes, safeName, w, h, dataType, dataFormat, drawMode) => {
    const formatByte = (b) => dataType === "uint16_t" 
      ? "0x" + b.toString(16).toUpperCase().padStart(4, "0")
      : "0x" + b.toString(16).toUpperCase().padStart(2, "0");
    
    const byteStr = bytes.map(formatByte).join(", ");
    
    // Generate working Arduino code based on draw mode
    if (drawMode.includes("1BIT") || drawMode.includes("ALPHA")) {
      return `// Generated by Pixel2CPP (${drawMode})
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

const uint16_t ${safeName}_w = ${w};
const uint16_t ${safeName}_h = ${h};
const ${dataType} ${safeName}_data[] PROGMEM = {
  ${byteStr}
};

Adafruit_SSD1306 display(128, 64, &Wire, -1);

void setup() {
  Serial.begin(9600);
  
  // Initialize display
  display.begin(SSD1306_SWITCHCAPVCC, 0x3C);
  display.clearDisplay();
  display.drawBitmap(0, 0, ${safeName}_data, ${safeName}_w, ${safeName}_h, 1);
  display.display();
}

void loop() {
  // Your main code here
}`;
    } else if (drawMode.includes("RGB565")) {
      return `// Generated by Pixel2CPP (RGB565)
#include <Adafruit_GFX.h>
#include <Adafruit_ST7735.h>

const uint16_t ${safeName}_w = ${w};
const uint16_t ${safeName}_h = ${h};
const ${dataType} ${safeName}_data[] PROGMEM = {
  ${byteStr}
};

#define TFT_CS   10
#define TFT_RST  9
#define TFT_DC   8

Adafruit_ST7735 tft = Adafruit_ST7735(TFT_CS, TFT_DC, TFT_RST);

void setup() {
  Serial.begin(9600);
  
  // Initialize display
  tft.initR(INITR_BLACKTAB);
  tft.setRotation(0);
  tft.fillScreen(ST77XX_BLACK);
  
  // Display the image
  drawImage(0, 0);
}

void drawImage(int16_t x0, int16_t y0) {
  tft.startWrite();
  tft.setAddrWindow(x0, y0, ${safeName}_w, ${safeName}_h);
  for (uint16_t i = 0; i < ${safeName}_w * ${safeName}_h; i++) {
    uint16_t color = pgm_read_word(&${safeName}_data[i]);
    tft.writePixel(color);
  }
  tft.endWrite();
}

void loop() {
  // Your main code here
}`;
    } else {
      // Fallback for other modes - generic display code with the data
      return `// Generated by Pixel2CPP (${drawMode})
#include <Adafruit_GFX.h>
// Add your display library here (e.g., #include <Adafruit_SSD1306.h>)

const uint16_t ${safeName}_w = ${w};
const uint16_t ${safeName}_h = ${h};
const ${dataType} ${safeName}_data[] PROGMEM = {
  ${byteStr}
};

// Add your display initialization here
// Example: Adafruit_SSD1306 display(128, 64, &Wire, -1);

void setup() {
  Serial.begin(9600);
  
  // Initialize your display here
  // Example: display.begin(SSD1306_SWITCHCAPVCC, 0x3C);
  
  // Add your image display code here
  // Example: display.clearDisplay();
  //          display.drawBitmap(0, 0, ${safeName}_data, ${safeName}_w, ${safeName}_h, 1);
  //          display.display();
}

void loop() {
  // Your main code here
}`;
    }
  };

  const generateArduinoCode = (bytes, safeName, w, h, dataType, dataFormat, drawMode) => {
    const formatByte = (b) => dataType === "uint16_t" 
      ? "0x" + b.toString(16).toUpperCase().padStart(4, "0")
      : "0x" + b.toString(16).toUpperCase().padStart(2, "0");
    
    const byteStr = bytes.map(formatByte).join(", ");
    
    if (drawMode.includes("1BIT")) {
      return `// Generated by Pixel2CPP (${drawMode})
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

const uint16_t ${safeName}_w = ${w};
const uint16_t ${safeName}_h = ${h};
const ${dataType} ${safeName}_${dataFormat}[] PROGMEM = {
  ${byteStr}
};

Adafruit_SSD1306 display(128, 64, &Wire, -1);

void setup() {
  display.begin(SSD1306_SWITCHCAPVCC, 0x3C);
  display.clearDisplay();
  display.drawBitmap(0, 0, ${safeName}_${dataFormat}, ${safeName}_w, ${safeName}_h, 1);
  display.display();
}

void loop() {}`;
    } else if (drawMode.includes("RGB565")) {
      return `// Generated by Pixel2CPP (RGB565)
#include <Adafruit_GFX.h>
#include <Adafruit_ST7735.h>

const uint16_t ${safeName}_w = ${w};
const uint16_t ${safeName}_h = ${h};
const ${dataType} ${safeName}_${dataFormat}[] PROGMEM = {
  ${byteStr}
};

#define TFT_CS   10
#define TFT_RST  9
#define TFT_DC   8

Adafruit_ST7735 tft = Adafruit_ST7735(TFT_CS, TFT_DC, TFT_RST);

void setup() {
  tft.initR(INITR_BLACKTAB);
  tft.fillScreen(ST77XX_BLACK);
  drawImage(0, 0);
}

void drawImage(int16_t x0, int16_t y0) {
  tft.startWrite();
  tft.setAddrWindow(x0, y0, ${safeName}_w, ${safeName}_h);
  for (uint16_t i = 0; i < ${safeName}_w * ${safeName}_h; i++) {
    uint16_t color = pgm_read_word(&${safeName}_${dataFormat}[i]);
    tft.writePixel(color);
  }
  tft.endWrite();
}

void loop() {}`;
    } else {
      return `// Generated by Pixel2CPP (${drawMode})
#include <Adafruit_GFX.h>

const uint16_t ${safeName}_w = ${w};
const uint16_t ${safeName}_h = ${h};
const ${dataType} ${safeName}_${dataFormat}[] PROGMEM = {
  ${byteStr}
};

// Add your display setup and drawing code here`;
    }
  };

  const generateArduinoSingleBitmap = (bytes, safeName, w, h, dataType, dataFormat) => {
    const formatByte = (b) => dataType === "uint16_t" 
      ? "0x" + b.toString(16).toUpperCase().padStart(4, "0")
      : "0x" + b.toString(16).toUpperCase().padStart(2, "0");
    
    const byteStr = bytes.map(formatByte).join(", ");
    
    return `// Single bitmap array - ${safeName}
// ${w}x${h} pixels, ${bytes.length} bytes
const ${dataType} ${safeName}[] PROGMEM = { ${byteStr} };`;
  };

  const generateGFXBitmapFont = (bytes, safeName, w, h) => {
    const byteStr = bytes.map((b) => "0x" + b.toString(16).toUpperCase().padStart(2, "0")).join(", ");
    
    return `// GFX Bitmap Font format - ${safeName}
#include <Adafruit_GFX.h>

const uint8_t ${safeName}Bitmaps[] PROGMEM = {
  ${byteStr}
};

const GFXglyph ${safeName}Glyphs[] PROGMEM = {
  { 0, ${w}, ${h}, ${w}, 0, 0 } // Single glyph covering entire bitmap
};

const GFXfont ${safeName} PROGMEM = {
  (uint8_t *)${safeName}Bitmaps,
  (GFXglyph *)${safeName}Glyphs,
  0, 0, ${h}
};`;
  };

  const exportCpp = (drawMode, outputFormat, w, h, data, name) => {
    const code = generateCppCode(drawMode, outputFormat, w, h, data, name);
    const safeName = name.replace(/[^a-zA-Z0-9_]/g, "_");
    download(`${safeName}.h`, code);
  };

  const handleGenerateCode = async () => {
    try {
      setIsGenerating(true);
      setShowCodeModal(true);
    } catch (error) {
      console.error('Error generating code:', error);
    } finally {
      setIsGenerating(false);
    }
  };

  const handleCopyCode = async (drawMode, outputFormat, w, h, data, name) => {
    const code = generateCppCode(drawMode, outputFormat, w, h, data, name);
    const success = await copyToClipboard(code);
    setCopyStatus(success ? "copied" : "error");
    setTimeout(() => setCopyStatus(""), 2000);
  };

  return {
    showCodeModal,
    setShowCodeModal,
    copyStatus,
    isGenerating,
    generateCppCode,
    exportCpp,
    handleGenerateCode,
    handleCopyCode
  };
}
